#ifndef MW_PARAMETERS_H_
#define MW_PARAMETERS_H_

#include <iostream>
#include <string>
#include <vector>
#include <map>
#include <boost/bind.hpp>
#include <boost/function.hpp>
#include <boost/shared_ptr.hpp>
#include <boost/lexical_cast.hpp>


#include "mw_abbreviations.h"
#include "mw_parameters_macros.h"
#include "mw_conversion_helpers.h"
#include <MWorksCore/ComponentFactory.h>


namespace mw {

  using namespace std;
  using namespace boost;

  // ------------------------------------------------
  // Base class for parameters, and associated stuff
  // ------------------------------------------------

  class MWBaseParameters;
 
  // a simple container for parameter information
  struct MWParameterDescription {
    
      // the tag name of the parameter
      string name;
      
      // A static helper function to set this parameter
      void (*static_setter)(shared_ptr<MWBaseParameters>, 
                            string,
                            ComponentRegistry*);
                            //shared_ptr<ComponentRegistry>);
      
      // A string representation of the default value
      string default_val;
      
      bool required;
      
      // TODO: add more fields
  };


  // A base class for object-specific parameter collection classes
  // Self describing components will contain an compile-time generated
  // inner class that extends from this class. 
  class MWBaseParameters {
  
    protected:
      
      // ---------------------------------------
      // Metaprogramming constructs
      // ---------------------------------------
      
      // meta_hook< fn >
      // A metafunction to enable calling an arbitrary static function
      // during static initialization.  The static function pointer is a template
      // argument.
      template <void (*U)()>
      class meta_hook {
      public:
          meta_hook(){
              U();
          }
      };
      
      // meta_token
      // An arbitrary compile-time token. We will use it to identify a particular
      // autogenerated class at run-time.  Implemented as a function pointer, but 
      // this is important but conceptually incidental to its operation 
      // (treat it as a type)
      typedef void (*meta_token)();
  
    public:
      
      MWBaseParameters(){ }
      virtual ~MWBaseParameters(){ } // needs at least one virtual method
                                     // for polymorphism to work correctly
             
      // A static, discoverable registry of parameters index by a 
      // compile-time meta_token generate for each automatic inner class
      static map<meta_token, vector<MWParameterDescription> > parameter_table;
    
      // Register a parameter description with the static parameter_table
      // this method is called indirectly during *static initialization* by a 
      // template metafunction
      static void registerParameter(meta_token id, 
                        string name,
                        void (*static_setter)(shared_ptr<MWBaseParameters>, 
                                              string,
                                              ComponentRegistry*),
                                              //shared_ptr<ComponentRegistry>),
                        string default_value,
                        bool required){               
                                      
        MWParameterDescription desc;
        desc.name = name;
        desc.static_setter = static_setter;
        desc.default_val = default_value;
        desc.required = required;
        parameter_table[id].push_back(desc);  
      }
      
      // Return a vector of parameter descriptions corresponding to a 
      // particular parameter inner class (indexed by it's "id" meta token)
      static vector<MWParameterDescription> getParameters(meta_token id){
        return parameter_table[id];
      }
      
      // Return an instantiated parameter collection object that is populated
      // using values from a string dictionary (e.g. as would come from the
      // parser)
      template <typename P>
      static shared_ptr<P> populate( map<string, string> params, 
                                     ComponentRegistry *reg){
                                     //shared_ptr<ComponentRegistry> reg ){
                                     
                        
        shared_ptr<MWBaseParameters> params_obj(new P()); 
        
        vector<MWParameterDescription> param_list = getParameters(P::id);
        vector<MWParameterDescription>::iterator i;
        for(i = param_list.begin(); i != param_list.end(); ++i){
          MWParameterDescription desc = *i;
          string name = desc.name;
          if(params.find(name) != params.end()){
            string value = params[name];
            cerr << "name: " << name << " value: " << value << endl;
            desc.static_setter(params_obj, value, reg);
          } else {
            desc.static_setter(params_obj, desc.default_val, reg);
          }
        }
        
        return dynamic_pointer_cast<P, MWBaseParameters>(params_obj);
        
      }

      
  };
}


#endif
